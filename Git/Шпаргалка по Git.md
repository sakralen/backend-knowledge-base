# Шпаргалка по Git
### Создание коммита
```
git commit -m "message"
```

### Создание новой ветки
```
git branch <name>
```

### Выбор существующей ветки
```
git checkout <name>
```

### Создание и одновременный выбор ветки
```
git checkout -b <name>
```

Можно вытворять такое:
```
git checkout -b <name> <commit-hash>
```

### Слияние с мёрдж-коммитом (git merge)
Находясь в **main**, мёрдж ветки **feature**:
```
git merge feature
```

### Слияние без мёрдж-коммита (git rebase)
Находясь в **feature**, ребэйс на **main**:
```
git rebase main
```

Может принимать \<dst> и \<src> (как бы в таком порядке...).

Если ветка **main** была предком **feature**, то _git rebase feature_ (находясь в main) просто передвинет **main** на коммиn **feature**.

### HEAD detaching
Присвоение HEAD не ветке, а конкретному коммиту:
```
git checkout <commit-hash>
```

C помощью относительных ссылок:
```
git checkout <branch-name>~N
```

При N == 1 можно воспользоваться ^:
```
git checkout <branch-name>^
```

Можно также использовать сам HEAD:
```
git checkout HEAD^
```

### Перемещение ветки (branch forcing)
```
git branch -f <src> <dst>
```

### Отмена изменений
_git reset_ подоходит для локальных изменений. _git reset_ перенесёт ветку назад, как будто некоторых коммитов вовсе и не было:
```
git reset HEAD~1
```

_git revert_ -- для удалённых веток. Создаётся коммит с изменениями, противоположными отменяемому (можно использовать HEAD):
```
git revert <commit-name>
```

### cherry-pick
Копирование отдельных коммитов туда, где в данный момент HEAD:
```
git cherry-pick <commit-hash-1> <commit-hash-2> <...>
```

### Интерактивный rebase:
```
git rebase -i <src>
```

Позволяет выбрать нужные коммиты, объединить их, выкинуть или поменять порядок.

### git commit --amend
Если нужно изменить последний коммит, но вы не внесли новые изменения, введите команду git commit -amend в терминале. Она открывает текстовый редактор по умолчанию, где можно отредактировать сообщение коммита. После внесения изменений просто сохраните файл. Если вам нужно добавить новые правки к последнему коммиту, сначала внесите их в свои файлы, затем выполните команду git add, чтобы указать их в индексе. Затем запустите команду git commit -amend, которая объединит новые правки с предыдущим коммитом. 

### Создание локальной копии удалённого репозитория
```
git clone
```

### git fetch
Cинхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.

Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

### git pull
git pull == git fetch && git merge origin/main

Также можно:
```
git pull --rebase
```

### git push
Команда git push отвечает за загрузку ваших изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория.

### Работа с изменившемся удалённым репозиторием:
```
git pull (--rebase)
git push
```

### Remote rejected!


## git config
```
git config --global user.name "username"
git config --global user.email "mail@mail.com"
git config --list
git config --global credential.helper store
```
