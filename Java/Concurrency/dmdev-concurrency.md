# Многопоточность
## 1. Общие сведения; Класс Thread
У каждого потока свой стек вызовов.
(*TODO*: добавить про program counter)

Чтобы получить текущий поток:
```java
Thread.currentThread()
```

Также у потока м.б. присутствовать имя:
```java
Thread.currentThread().getName()
```

Два варианта создания потока:

- Унаследовать **Thread**
- Реализовать интерфейс **Runnable**

При наследовании **Thread** (и при реализации интерфейса **Runnable**) следует переопределить метод **run()**.

Создание потока через **new** != запуск потока.

Если вызвать у потока **run(),** то *он исполнится в текущем потоке!* Поэтому следует вызывать метод **start()**.

Для ожидания текущим потоком другого потока, следует в текущем потока вызвать у другого потока метод **join()**:
```java
public static void main(String[] args) {
    SimpleThread st = new SimpleThread();
    st.start();
    st.join(); 
}
```

**join()** выбрасывает **InterruptedException**. 

Для остановки потока возможен вызов метода **interrupt()**, который как раз и провоцирует **InterruptedException** (*TODO*: проверить).

## 2. Интерфейс Runnable
Является функциональным интерфейсом, соотвественно можно задавать Runnabl'ы с помощью лямбда-выражений.

Т.к. нет наследования от **Thread**, то доступ к потоку получается через **Thread.currentThread()**.

Для запуска потока требуется создать объект класса **Thread**:
```java
new Thread(new Runnable());
```

## 3. Состояния потоков
Для получения состояния потока необходимо вызвать у него метод **getState()**. 

Возможные состояния:
- **NEW** - созданный;
- **RUNNABLE** - выполняется;
- **BLOCKED** - заблокирован другим потоком;
- **WAITING** - ожидание (например, **join()**);
- **TIMED_WAITING** - ожидание с тайм-аутом;
- **TERMINATED** - закончено выполнение.

Если поток закончил выполнение, еще раз его не запустить. Необходимо создать новый объект **Thread**.

## 4. Атомарность операций
Операция инкремента не является атомарной:
1. Считывание;
2. Изменение;
3. Запись.

Несколько потоков могут считать одно и то же значение, из-за чего измения одним потоком могут пропасть.

## 5. synchronized
Позволяет сделать блок кода атомарным.

Возможно использовать **synchronized** на уровне метода и на уровне блока.

Передаваемый объект в **synchronized** позволяет осуществлять захват **монитора** на переданном объекте (как бы если есть sync-блоки в разных методах, монитор может быть один, ну вы поняли).

**synchronized** является **Reentrant**!

**Монитор** == **intrinsic lock** == **monitor lock**

**Mutex** по самой сути, хотя в документации так его не называют.

**synchronized** на уровне метода на **this**, static метода - на **Clazz.class**.

## 6. Синхронизация коллекций
Короче, внутри ничего не синхронизировано! Кэш всё путает!

Чтобы синхронизировать коллекцию, можно использовать утилитный метод **Collections.synchronizedList(list).**

Зачем делать отдельный **Object mutex** - разделение обязанностей!

**Collections.synchronizedList(list)** - лучше использовать в крайних случаях, так как захват монитора является ресурсозатратным.

На практике встречается редко. Используются потокобезопасные коллекции.

## 7. volatile
Один поток может не увидеть изменения, сделанные другим потоком (из-за кэширования).

**volatile** - получать информацию из хипа, а не из кэша. Также спасает от перестановки строк. (*TODO*: вспомнить про Happens Before Guarantee)

Работает для примитивных типов и для ссылок.

## 8. Потокобезопасный объект
Тупо: не создавать общие ресурсы: создавать только локальне переменные.

Тупо: объект без полей == без состояния.

**Immutable** объекты:
- При изменении объекта возвращать новый объект;
- Создавать read-only методы (Нужно быть осторожным с коллекциями: **List.copyOf()** делает иммутабельную копию! Или возвращать **new**);
- Синхронизировать методы.

## 9. wait(), notify(), notifyAll()
Методы класса **Object**.

**Thread.sleep()** не освобождает монитор! 

**wait()** вызываем у объекта-монитора -> монитор освободится -> нужно захватить монитор снова (происходит автоматически).

Если **wait()** без тайм-аута, то другие потоки будут ожидать, пока не будет вызван один из notify-методов.

**notify()** - один рандомный поток, **notifyAll()** - все.

**while** лучше внутри **synchronized** для того, чтобы не захватывать монитор снова.

## 10. Deadlock
Вложенный synchronized на разных объектах череват deadlock'ом.

## 11. java.util.concurrent
Атомики - обертка для примтивов\ссылок
Локи - классы для блокирования мониторов
Коллекции - безопасные коллекции для многопоточности
Thread pools/Executor services - создание потоков
Фьючеры
Семафор, Лэтчи, Барьеры...

Напрямую не работают с synchronized, wait... Класс **Unsafe** -> буст производительности.

## 12. Atomic
**increment()**, **addAndGet()**...

Работает через **Unsafe** объект - работа с памятью на низком уровне. Реализации методов - **native**. Используются CAS-операции: сравнение + замена. Сравнение старого значение с прочитанным, пока они не совпадут.

(**TODO**: CAS)

## 13. Lock
Отдельный объект для захвата монитора. 

**tryLock()** - пытается и не блокирует. Позволяет бороться с дэдлоком следующей конструкцией:

```java
while(true) {
    boolean fromLockResult = accountFrom.getLock().tryLock();
    boolean toLockResult = accountTo.getLock().tryLock();

    if (fromLockResult && toLockResult) {
        break;
    }

    if (fromLockResult) {
        accountFrom.getLock().unlock();
    }

    if (toLockResult) {
        accountTo.getLock().unlock();
    }
}
```

Условия - **newCondidtion()** - логика wait + notify.

Не забывать отпускать локи в блоке **finally**!

ReentrantLock - позволяет захватывать уже захваченный собой лок.

Есть ReadWriteLock'и - содержат Read и Write локи.

## 14. ThreadPool; Future; Callable
Создание потока - ресурсозатратно. Есть смысл переиспользовать созданные потоки.

Суть - synchronized очередь задач.

**Executors** - утилитный класс для создания пулов потоков.

- **Executors.newSingleThreadExecutor()** - один поток;
- **Executors.newFixedThreadPool()** - кол-во потоков;
- **Executors.newCachedThreadPool()** - сколько задач == столько потоков; но новые потоки создаваться не будут, они будут браться из пула, если есть свободные;
- **Executors.newScheduledThreadPool()** - задачи с периодичностью/задержкой;
- **Executors.newWorkStealingPool()** - на основе **ForkJoinPool**: создает пул потоков оптимально под кол-во процессоров.

Возвращается **ExecutorService.**

Для поставки задачи используется метод **submit(Callable)**. **Callable**, в отлчии от **Runnable,** возвращает значение-результат. Сам **submit()** возвращает **Future**.

Также **Callable,** в отлчии от **Runnable**, пробрасывает исключение.

**execute()** - не возвращает значения.

Для завершения пула - **shutdown()** или **shutdownNow()**. **awaitTermination()** - тайм-аут завершения.

**Future** - отложенное выполнение (неблокирующее). **get()** - блокирует.

**threadpool.invokeAll()** - для списка **Callable**.

(*TODO*: CompletableFuture)

**ScheduledThreadPool** - задержка, периодичность.

## 15. Потокобезопасные коллекции
Blocking(De)Queue
ConcurrentMap, Set...

Аналог **ArrayList** - **CopyOnWriteArrayList** - не блокирует поток по чтению, а по записи - делает копию: потоки, желающие записать ждут, а читающие - читают старую версию.

**BlockingQueue**: **take()** - ожидает, если пусто.

## 16. CountDownLatch
Общий ресурс?

**await()** - ожидание.
**countdown()** - декремент.

## 17. CyclicBarrier
Есть только **await()** - ожидает,пока сколько-то потоков не вызовут **await()**.

**await()** не освобождает поток!

Есть action по завершению!

## 18. Semaphore
Ограничивает доступ к коду.

**acquire()** - захват монитора.
Позволяет указать кол-во единиц разделяемого ресурса!

**release()** - освободить.

Нет владельца -> любой поток может освободить его!

## 19. ThreadLocal
Хранят для потока собственное значение.
**get()** -- ассоц. массив: ключ - поток, значение - значение ThreadLocal.
**set()**
**remove()**

**Stream.parallel()** можно submit'нуть в **ExecutorService**! Тогда стрим будет использовать необходимый пул!

(*TODO*: Phaser)
