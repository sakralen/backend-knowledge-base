# Базы данных
## Нормальные формы
Источники: 
- [Базы данных. 1,2,3 нормальные формы.](https://www.youtube.com/watch?v=zwQzL80U51c&t=5s)
- [Базы данных. НФ БК; 4-5 нормальные формы](https://www.youtube.com/watch?v=y5MeJ3bc-OA)

### Нормализация
Устранения избыточности производится, как правило, за счёт декомпозиции отношений таким образом, чтобы в каждом отношении хранились только первичные факты (т. е. факты, не выводимые из других хранимых фактов).

Избыточность - хранение большего количества данных, нежели необходимо. Избыточность ведёт к:
- Увеличению занимаемого места на диске;
- Аномалиям включения, обновления, удаления.

Нормальные формы:
- 1 НФ
- 2 НФ
- 3 НФ
- НФ Бойса-Кодда (усиленная 3 НФ)
- 4 НФ
- 5 НФ
- 6 НФ
- Доменно-ключевая НФ

### 1 НФ
- Значение атрибута должно быть атомарным.
- Не должно быть повторяющихся строк.

Пример: 
- | name | hobbies |
  | --- | --- |
  | Алексей | Коньки, Мотоцикл |
  | Ярослав | Фотграфия, Велосипеды |

  После нормализации:
  | name | hobbies |
  | --- | --- |
  | Алексей | Коньки |
  | Алексей | Мотоцикл |
  | Ярослав | Фотграфия |
  | Ярослав | Велосипеды |

### 2 НФ
- Таблица в 1 НФ
- Есть первичный ключ
- Все атрибуты зависят от ключа целиком, а не от какой-то его части
  
Пример:
- | name | project | project_client |
  | --- | --- | --- |
  | Алексей | КайзерДом | Сергей |
  | Алексей | Юнитраст | Иван |
  | Ярослав | Доска почёта | Аркадий
  | Илья | КайзерДом | Сергей |
  | Роман | КайзерДом | Сергей |
  | Роман | Юнитраст | Иван |

  Добавим первичный ключ (составной worker_id, project_id):
  | worker_id | project_id | name | project | project_client |
  | --- | --- | --- | --- | --- |
  | 1 | 1 | Алексей | КайзерДом | Сергей |
  | 1 | 2 | Алексей | Юнитраст | Иван |
  | 2 | 3 | Ярослав | Доска почёта | Аркадий
  | 3 | 1 | Илья | КайзерДом | Сергей |
  | 4 | 1 | Роман | КайзерДом | Сергей |
  | 4 | 2 | Роман | Юнитраст | Иван |

  Но имя сотрудника зависит от одной части первичного ключа, а проект - от другой. Решение - декомпозиция:
  | project_id | project | project_client |
  | --- | --- | --- |
  | 1 | КайзерДом | Сергей |
  | 2 | Юнитраст | Иван |
  | 3 | Доска почёта | Аркадий |

  | worker_id | project_id |
  | --- | --- |
  | 1 | 1 |
  | 1 | 2 |
  | 2 | 3 |
  | 3 | 1 |
  | 4 | 1 |
  | 4 | 2 |

  | worker_id | name |
  | --- | --- |
  | 1 | Алексей |
  | 2 | Ярослав |
  | 3 | Илья |
  | 4 | Роман |

### 3 НФ
  - Таблица в 2 НФ
  - Все атрибуты зависят только от первичного ключа, но не от других атрибутов
  
Пример:
- | tyre_id | tyre_name            | supplier                | supplier_phone  |
  |---------|----------------------|-------------------------|-----------------|
  | 1       | Nokian Hakka         | ИП Шплепаков Л.         | +79233213123    |
  | 2       | Nokian Nordman       | ООО Русский Север       | +79242343423    |
  | 3       | Continental Contlice | ООО Автомакс            | +794342432434   |
  | 4       | Matador              | ИП Кузнецов П.          | +79984932484    |
  | 5       | Nordmaster           | ИП Иванов П.            | +79645654345    |

  После нормализации:
  | tyre_id | tyre_name            | supplier_id |
  |---------|----------------------|-------------|
  | 1       | Nokian Hakka         |      1      |
  | 2       | Nokian Nordman       |      2      |
  | 3       | Continental Contlice |      3      |
  | 4       | Matador              |      4      |
  | 5       | Nordmaster           |      5      |

  | id | supplier           | supplier_phone  |
  |----|--------------------|-----------------|
  | 1  | ИП Шплепаков Л.    | +79233213123    |
  | 2  | ООО Русский Север  | +79242343423    |
  | 3  | ООО Автомакс       | +794342432434   |
  | 4  | ИП Кузнецов П.     | +79984932484    |
  | 5  | ИП Иванов П.       | +79645654345    |

### НФ Бойса-Кодда (усиленная 3 НФ)
- Таблица в 3 НФ
- Ключевые атрибуты не должны зависеть от неключевых

Пример:
- | project_id | task          | responsible |
  |------------|---------------|-------------|
  | 1          | Разработка    | Рома        |
  | 2          | Маркетинг     | Максим      |
  | 2          | Дизайн        | Илья        |
  | 1          | Дизайн        | Илья        |
  | 3          | Маркетинг     | Диана       |
  | 3          | Разработка    | Миша        |

  Первичный ключ - составной (project_id & task). Но проявляется зависимость части первичного ключа (задачи) от отвественного: зная, кем является отвественный, можно четко определить его задачу.

  | id         | name          | skill       |
  |------------|---------------|-------------|
  | 1          | Рома          | Разработка  |
  | 2          | Максим        | Маркетинг   |
  | 2          | Илья          | Дизайн      |
  | 1          | Илья          | Дизайн      |
  | 3          | Диана         | Маркетинг   |
  | 3          | Миша          | Разработка  |

  | project_id | responsible_id |
  | --- | --- |
  | 1 | 1 |
  | 2 | 2 |
  | 2 | 3 |
  | 1 | 4 |
  | 3 | 5 |
  | 3 | 6 |

### 4 НФ
- Таблица находится в НФ БК
- Устраняются многозначные зависимости

Пример:
- | worker_id | project      | hobbie      |
  |-----------|--------------|-------------|
  | 1         | Сантехник    | Радиотехника|
  | 1         | КайзерДом    | Гитара      |
  | 2         | FabioRoss    | Футбол      |
  | 3         | КайзерДом    | Хоккей      |
  | 3         | Доска Почета | Гитара      |

  Атрибуты Проект и Увлечение напрямую зависят от первого столбца, но друг от друга они не зависят. Еще одна проблема - выбрать все хобби сотрудников, участвующих в проекте "КайзерДом": потеряются хобби некоторых сотрудников.

  Решение:
  | worker_id | hobbie      |
  |-----------|-------------|
  | 1         | Радиотехника|
  | 1         | Гитара      |
  | 2         | Футбол      |
  | 3         | Хоккей      |
  | 3         | Гитара      |

  | worker_id | project      |
  |-----------|--------------|
  | 1         | Сантехник    |
  | 1         | КайзерДом    |
  | 2         | FabioRoss    |
  | 3         | КайзерДом    |
  | 3         | Доска Почета |

### 5 НФ
  - Таблица находится в 4 НФ
  - Устраняются нетривиальные зависимости
  - (Декомпозиция без потерь)

### Заключение
- **1 НФ**:
  - Значение атрибута должно быть атомарным.
  - Не должно быть повторяющихся строк. 
- **2 НФ**:
  - Таблица в 1 НФ
  - Есть первичный ключ
  - Все атрибуты зависят от ключа целиком, а не от какой-то его части 
- **3 НФ**:
   - Таблица в 2 НФ
   - Все атрибуты зависят только от первичного ключа, но не от других атрибутов
- **НФ БК:**
  - Таблица в 3 НФ
  - Ключевые атрибуты не должны зависеть от неключевых


## Индексы
Источники: 
- [Базы данных. MySQL. Индексы](https://www.youtube.com/watch?v=RUF3n_EIcy8)
- [SQL. 28. Индексы. B-Tree. Часть 1](https://www.youtube.com/watch?v=T3IcFTu4SsU&list=PLnh8EajVFTl5q3x1Mp6Fh9YEvv70dL6re&index=28)
- [SQL. 28. Индексы. B-Tree. Часть 2](https://www.youtube.com/watch?v=wyNbzat-3iE&list=PLnh8EajVFTl5q3x1Mp6Fh9YEvv70dL6re&index=29)
- [Кластерные и «обычные» индексы MySQL (InnoDB)](https://habr.com/ru/articles/141767/)

Дополнительно:
https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql
http://highload.guide/blog/basics_indexing.html

Оффтоп: **DESCRIBE** - крутой оператор!

Если БД не знает, как хранятся данные, и какие запросы будут исполняться, БД будет прохоить таблицу полностью. Это называется *FULL SCAN*. Таким образом, количесвто проверок при поиске будет равно количеству записей в таблице.

Мощность какого-то отдельного домена м. б. сильно меньше количества всех записей в таблице. Для такого атрибута можно ввести индекс.

- Можно построить таблицы, содержащую только атрибут и какую-то доп. информацию, по которому происходит поиск. Количество проверок будет равно мощности домена атрибута. **Индексы работают не так**.

- Поиск по индексу, основанном на B-дереве, будет производится, фактически, лексиграфически (подозреваю, что это префиксное дерево):

  | Этап поиска | Количество совпадений |
  | --- | --- |
  | Z___ | 59 |
  | ZE__ | 14 |
  | ZEU_ | 8 |
  | ZEUS | 1 |

  Количество проверок равно сумме совпадений. Круто, но **индексы работают не так**.

- Для поиска отдельный буквы можно использовать бинарный поиск (предварительно отсортировав данные)!

  | Этап поиска | Количество совпадений | log(n) |
  | --- | --- | --- |
  | Z___ | 59 | 6 |
  | ZE__ | 14 | 4 |
  | ZEU_ | 8 | 3 |
  | ZEUS | 1 | 1 |

  И всего получается 14 проверок!
  **Вот так работают B-tree индексы**.

Пример добавления индекса:
```sql
ALTER TABLE table_name ADD INDEX index_name (attribute_name);
```

Чтобы посмотреть индексы:
```sql
SHOW INDEX FROM table_name;
```

Атрибуты в таблице индексов:
- Table
- Non_unique {0, 1} - уникальный или нет. ПО первичному ключу индекс всегда уникальный.
- Key_name 
- Seq_in_index - позиция в индексе (можно ставить индекс на 2 и более атрибутов).
- Column_name
- Cardinality - покрытие индекса.
- Null - есть ли NULL или нет.
- Index_type - тип индекса (в этой лекции речь идёт про B-tree индексы).

При добавлении индекса на два атрибута, следует располагать их в правильном порядке, так как следует учитывать **селективность** индекса: сначала по тому атрибуту, чье знаение соотвествует меньшему количеству строк. Другими словами, **чем меньшему количеству строк соотвествует значение атрибута, тем выше селективность. Такие атрибуты следует использовать в начале индекса**. Seq_in_index отвечает за порядок.

**Атрибуты, используемые в ORDER BY, следует добавлять в конец индекса**.

Если выполнить **EXPLAIN** запроса, который использует индексы, то за них будут отвечать аттрибуты
- possible_keys - возможные индексы для применеия
- key - примененный индекс
- key_len - длина индекса (ключа)

В составном индексе даже его часть может быть использована в запросе.
Чтобы определить, полностью использвется ли ключ, следует посчитать количество байт, занимаемых типов атрибута. Из середины составного индекса, индекс, похоже, не вытащить. 

Предостережения:
- Не нужно заранее создавать индексы
- Удаляйте неиспользуемые индексы
- Не используйте инжексы на небольших (до нескольких тычсяч записей) таблицах
- Исходите их медленных запросов - создавайте уникальные индексы под них
- Перед созданием индексов в проде - крайне желательно проверить на локальной копии данных

В PostgreSQL есть несколько типов индексов, в т. ч. и B-tree индексы.

На каждом узле B-дерева находятся несколько элементов. Важно определять количество элементов на каждом узле, так как **один узел полностью хранится на одном сегменте на ЖД** (несколько узлов в одном сегменте тоже бывает). Перемещение с одного узла на другой должны перемещать нас либо внутри одного сегмента, либо целиком на другой сегмент. Компьютер считывает целый сегмент за раз => меньшее кол-во обращенийк ЖД за раз.

Индекс в элементе узла также хранит ссылку на реальную таблицу (на другой файл: индекс - это а один файл, а таблица - другой). Ссылка м. б. представлена байтовым смещением от начала таблицы до искомой строки.

Для минимизации перемещения по ссылкам, есть **кластерные индексы**, которые хранят всю строку таблицы! На одну таблицу м.б. только один кластерный индекс!

**На PRIMARY KEY индекс создаётся автоматически!**

На маленьких таблицах индексы м. б. неэффективны.

Если в поиске необходимо выбрать только индекс, переход в другой файл не происходит.

**UNIQUE** индекс выбирает только одну строчку, вместо обычно индекса с несколькими строчками! В случае обычного индекса, если есть доп. фильтрация, то далее будет произведен поиск по атрибуту, по которому просходит доп. фильтрация.

Чем ближе селективность (**count(disinct indexed) / count(*)**) к 1, тем лучше. Составные индексы очень хороши в нормализированной таблице!

**Каждая вставка, обновление или удаление обновляют индексы => замедление**.

Кластерные индексы отличаются от некластерных точно так же, как оглавление книги отличается от алфавитного указателя. Алфавитный указатель (некластерный индекс) для точного слова (значения) даёт точные номера страниц (строки в БД). Оглавление же указывает диапазон страниц, соответствующих определённой главе, в которой уже найдётся искомое слово. Причём каждая глава, если она достаточно велика, может содержать собственное оглавление.

Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке.
